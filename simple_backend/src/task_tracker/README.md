	Минусы подхода с хранением задач в оперативной памяти (списке python)
1. Когда сервер выключается, значения из списка теряются.
2. Нет доступа из других процессов или серверов, так как список существует только в памяти.
3. Нет долговременного хранения, то есть если произойдет сбой не получится обратиться к данным.
4. Нельзя масштабировать приложение, так как при запуске нескольких серверов, они не смогут обращаться к данным
другого сервера(списку)
5. Нельзя анализировать данные, так как доступ к ним лишь на одном сервере, пока он работает.

	Что улучшилось после того, как список из оперативной памяти изменился на файл проекта?
1. Теперь при перезапуске сервера данные не потеряются.
2. Все данные хранятся отдельно в удобном формате и читаемом виде.
	Избавились ли мы таким способом от хранения состояния или нет?
Частично избавились, теперь храним состояние в отдельном файле, а не в оперативной памяти.
	Где еще можно хранить задачи и какие есть преимущества и недостатки этих подходов?
	Преимущества JSON:
Просто и понятно
Не требует дополнительных библиотек
Читаемый формат
	Недостатки JSON:
Конфликты при одновременной записи
Неэффективно при большом количестве данных
Нет транзакций / индексов
	SQLite / PostgreSQL / MySQL (реляционные БД)
	Преимущества:
Безопасное многопользовательское хранение
Быстрый поиск, фильтрация, сортировка
Транзакции и миграции
	Недостатки:
Нужно подключение и знание SQL
Немного сложнее в развертывании
NoSQL (например, MongoDB)
	Преимущества:
Гибкость в структуре данных
Поддержка масштабирования
Подходит для JSON-подобных данных
	Недостатки:
Нет строгой схемы (что может быть минусом)
Иногда хуже работает с отношениями между сущностями
	Redis / Memcached (в оперативной памяти)
	Преимущества:
Очень быстрый доступ
Подходит для кэша и временных данных
	Недостатки:
Потеря данных при перезапуске
Не подходит для долгосрочного хранения
	Состояние гонки при работе с JSON-файлом
	Возможные решения:
1. Ввод блокировок на файловые операции (например, с использованием `asyncio.Lock` или `threading.Lock`).
2. Переход к использованию базы данных (например, SQLite, PostgreSQL), где параллельный доступ обрабатывается корректно.
3. Промежуточный кэш с периодической синхронизацией (например, хранение в памяти с периодической записью в файл).

На текущем этапе рекомендуется использовать API только в однопоточном режиме для предотвращения потери данных.
